\documentclass[11pt, a4paper]{article}

% --- UNIVERSAL PREAMBLE BLOCK ---
% Set geometry for sensible margins
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2cm, right=2cm]{geometry}

% Load font and language packages
\usepackage{fontspec}
\usepackage[english, bidi=basic, provide=*]{babel}

% Provide the main language (English)
\babelprovide[import, onchar=ids fonts]{english}

% Set default/Latin font to Sans Serif in the main (rm) slot
% Noto Sans is clean and modern, good for a whitepaper.
\babelfont{rm}{Noto Sans}
% --- END UNIVERSAL PREAMBLE BLOCK ---

% --- Additional Packages ---
\usepackage{amsmath} % For math notation like P(A)
\usepackage{booktabs} % For professional tables
\usepackage{graphicx} % For placeholder box
\usepackage{titling} % For author/title formatting
\usepackage{parskip} % Removes paragraph indentation and adds space between them

% --- hidelinks MUST be the last package loaded ---
\usepackage[hidelinks]{hyperref}

\title{\textbf{Facemelt: A Novel AMM for Unified Spot and Leverage Trading}}
\author{
    calmxbt\\
    \href{https://github.com/calmdentist/facemelt}{https://github.com/calmdentist/facemelt}
}
\date{June 2025}

\begin{document}

\maketitle

\begin{abstract}
This whitepaper introduces \emph{Facemelt}, a novel automated market maker (AMM) that allows both spot and leverage trading within a unified liquidity framework for long-tail assets. By employing the Uniswap V2 style invariant with modifications to accommodate leveraged positions, Facemelt enables a rich trading experience while ensuring the underlying AMM remains solvent at all times. Facemelt also allows for asset creation without seed capital for assets that meet certain criteria. We describe the mathematical foundation - operational mechanics for opening and closing leveraged positions and liquidations.
\end{abstract}

\section{Introduction}

Existing perpetual DEXs are based on the vAMM model, which resembles traditional perpetual futures contracts built on an AMM. However, this model has several limitations:

\begin{itemize}
    \item Fragmented liquidity: separate liquidity pool for leverage trading.
    \item Counterparty risk: Longs require shorts as counterparties to trade, and vice-versa.
    \item Oracles: Oracles are used to fetch spot prices from external sources. This assumes trust and creates attack vectors.
\end{itemize}

Facemelt unifies spot and leverage trading within a single liquidity pool - providing deeper liquidity, reducing counterparty risk, and eliminating the need for oracles.

\section{Mathematical Foundation}

At its core, Facemelt uses a constant product invariant. However, to support a unified market for spot and leverage trading, it introduces the critical concepts of \textbf{real reserves} and \textbf{effective reserves}.

\begin{itemize}
    \item \textbf{Real Reserves ($x_r, y_r$)}: The actual amount of SOL and tokens held in the protocol's vaults. These are only ever changed by spot traders depositing or withdrawing assets.
    \item \textbf{Effective Reserves ($x_e, y_e$)}: The virtual reserves that all trades are priced against. For spot trades, $x_e$ and $y_e$ are changed in lockstep with $x_r$ and $y_r$. For leverage trades, only the effective reserves are modified, reflecting the virtual nature of the positions.
\end{itemize}

Leverage is made possible by allowing the effective reserves to deviate from the real reserves. The difference represents the total outstanding debt owed to the pool by leverage traders. This debt is denominated in an abstract, price-agnostic unit of liquidity called \textbf{delta k ($\Delta k$)}.

\subsection{Core Variables}

The protocol tracks the following state variables:
\begin{itemize}
    \item $x_r, y_r$: The real reserves of the base asset and token.
    \item $x_e, y_e$: The live, effective reserves of the base asset and token.
    \item $\sum \Delta k_{\text{longs}}$: The sum of original $\Delta k$ from all open long positions.
    \item $\sum \Delta k_{\text{shorts}}$: The sum of original $\Delta k$ from all open short positions.
    \item $I(t)$: A cumulative funding index used to calculate the state of individual positions.
\end{itemize}
The fundamental relationship for any swap is against the effective reserves:
\begin{equation}
x_e \cdot y_e = k_e
\end{equation}

\section{Leverage Trading Mechanism}

Similarly to traditional derivative contracts, leveraged positions on Facemelt are virtual claims on pool value rather than physical token ownership.

\subsection{Opening a Leveraged Position}
A leveraged position is created by swapping a notional amount (collateral $\times$ leverage) against the AMM's effective liquidity. The collateral is always denominated in the input asset of the swap, and the position's virtual size is denominated in the output asset.

\subsubsection{Long Position (Base Asset as Collateral)}
To open a long position on the token, a trader provides collateral $c_x$ in the base asset. The notional value ($c_x \times L$) is swapped virtually to determine the position size, $\Delta y$:
\begin{equation}
\Delta y = \frac{y_{\text{pre}} \cdot (c_x \cdot L)}{x_{\text{pre}} + (c_x \cdot L)}
\end{equation}
This $\Delta y$ becomes the position's virtual size, denominated in the token asset.

\subsubsection{Short Position (Token as Collateral)}
To open a short position on the token, a trader provides collateral $c_y$ in the token asset - note that shorting with sol as collateral is equivalent to an atomic spot buy + leverage sell. The notional value ($c_y \times L$) is swapped virtually to determine the position size, $\Delta x$:
\begin{equation}
\Delta x = \frac{x_{\text{pre}} \cdot (c_y \cdot L)}{y_{\text{pre}} + (c_y \cdot L)}
\end{equation}
This $\Delta x$ becomes the position's virtual size, denominated in the base asset.

In both cases, the output amount is not physically transferred; it is an accounting entry representing a claim on pool value. The borrowed liquidity, $\Delta k$, is calculated as the reduction in the constant product caused by the virtual swap. Let $x_{\text{post}}$ and $y_{\text{post}}$ be the virtual reserves after the notional swap:
\begin{equation}
\Delta k = k_{\text{pre}} - k_{\text{post}} = (x_{\text{pre}} \cdot y_{\text{pre}}) - (x_{\text{post}} \cdot y_{\text{post}})
\end{equation}

This $\Delta k$ value is stored with the position and represents the liquidity borrowed from the pool. The trader must repay this borrowed liquidity through:
\begin{enumerate}
    \item \textbf{Continuous funding payments}: Accrued over the position's lifetime at a rate that increases quadratically with the pool's total leverage
    \item \textbf{Final settlement}: Any remaining debt is settled when closing the position
\end{enumerate}

\section{Global LP Funding Rate}
To compensate liquidity providers for the borrowed liquidity, Facemelt implements a global funding rate that continuously repays the outstanding $\Delta k$ debt, realizing it as an increase in the pool's effective reserves. This mechanism is designed to increase quadratically with total leverage, creating a strong economic incentive to maintain a healthy pool state.

\subsection{Funding Rate Formula}
The funding rate is a function of the total borrowed liquidity relative to the pool's current effective liquidity.
\begin{align}
\sum \Delta k_{\text{total}} &= \sum \Delta k_{\text{longs}} + \sum \Delta k_{\text{shorts}} \\
k_e &= x_e \cdot y_e \\
\text{LeverageRatio} &= \frac{\sum \Delta k_{\text{total}}}{k_e}
\end{align}
The funding rate per unit time is then:
\begin{equation}
    \text{FundingRate} = C \cdot (\text{LeverageRatio})^2
\end{equation}
where $C$ is a configurable constant.

\subsection{Implementation via Proportional Distribution}
The protocol continuously and atomically updates its global state based on this funding rate. For any time interval $\Delta t$, the fees paid by each side of the market are calculated proportional to their share of the total debt:
\begin{align}
\text{Fees}_{\text{longs}} &= \text{FundingRate} \cdot (\sum \Delta k_{\text{longs}}) \cdot \Delta t \\
\text{Fees}_{\text{shorts}} &= \text{FundingRate} \cdot (\sum \Delta k_{\text{shorts}}) \cdot \Delta t
\end{align}
These fees, which are denominated in units of $k$, must be converted back into their respective reserve assets to be realized. Long positions borrow the token, so their fee payments increase the effective token reserve. Short positions borrow the base asset, so their payments increase the effective base asset reserve.
\begin{align}
\Delta y_e &= \frac{\text{Fees}_{\text{longs}}}{x_e} \\
\Delta x_e &= \frac{\text{Fees}_{\text{shorts}}}{y_e}
\end{align}
The effective reserves and debt pools are then updated. Simultaneously, the cumulative funding index $I(t)$ is updated for calculating individual position states.

\subsection{Position Amortization via Funding}
Funding payments act as a continuous amortization of the position's virtual debt ($\Delta k$) and its corresponding virtual claim on the pool's assets ($y_{\text{position}}$). This process is denominated in units of $k$, the AMM's constant product, representing a claim on the pool's abstract liquidity rather than a specific asset. This ensures the funding mechanism is independent of asset price fluctuations. As a position accrues funding fees, both its effective size and its effective debt decrease proportionally.

To track this, we introduce the \textbf{Position Remaining Factor}, $f(t)$, for a position opened at time $t_{\text{open}}$:
\begin{equation}
    f(t) = 1 - (I(t) - I(t_{\text{open}}))
\end{equation}
This unitless factor represents the fraction of the original position that remains after accounting for funding payments. It allows us to calculate the effective values at any time $t$:

\begin{itemize}
    \item \textbf{Effective Position Size}: $y_{\text{effective}}(t) = y_{\text{original}} \cdot f(t)$
    \item \textbf{Effective Borrowed Liquidity}: $\Delta k_{\text{effective}}(t) = \Delta k_{\text{original}} \cdot f(t)$
\end{itemize}

As the cumulative index $I(t)$ grows, $f(t)$ decreases, ensuring that both the position's claim and its debt are paid down over time.

\section{Closing a Leveraged Position}

When a trader closes their position at time $t_{\text{close}}$, the protocol uses the effective position size and effective borrowed liquidity to calculate the final payout. This process ensures that all accrued funding fees are settled implicitly within the closing swap.

The steps are as follows:
\begin{enumerate}
    \item \textbf{Calculate the Position Remaining Factor}: The protocol first computes the remaining factor for the position based on the cumulative funding index:
    \begin{equation}
        f(t_{\text{close}}) = 1 - (I(t_{\text{close}}) - I(t_{\text{open}}))
    \end{equation}
    
    \item \textbf{Determine Effective Values}: Using this factor, the effective position size ($S_{\text{effective}}$) and effective borrowed liquidity ($\Delta k_{\text{effective}}$) are calculated from their original values.

    \item \textbf{Calculate Payout}: The final payout is determined by swapping the effective position size against the pool's current effective reserves while accounting for the repayment of the final effective borrowed liquidity.

    For a long position (collateral in base asset, effective size $y_e$), the payout $P_{\text{base}}$ is:
    \begin{equation}
        P_{\text{base}} = \frac{x_e \cdot y_e - \Delta k_{\text{effective}}}{y_e + y_{\text{effective}}}
    \end{equation}

    For a short position (collateral in token asset, effective size $x_e$), the payout $P_{\text{token}}$ is:
    \begin{equation}
        P_{\text{token}} = \frac{y_e \cdot x_e - \Delta k_{\text{effective}}}{x_e + x_{\text{effective}}}
    \end{equation}
\end{enumerate}

Upon closing, the position's original $\Delta k$ is removed from its respective debt pool ($\sum \Delta k_{\text{longs}}$ or $\sum \Delta k_{\text{shorts}}$), and the effective reserves are updated by performing a reverse virtual swap of the position's effective size to settle its claim and receive the payout.

\section{Liquidation Mechanism}

A position becomes liquidatable when its payout is less than or equal to 5\% of its gross value. However, to prevent manipulation-based liquidations, Facemelt employs an \textbf{EMA Price Oracle} that blocks liquidations when rapid price movements are detected.

\subsection{EMA Oracle Protection}

The protocol tracks an exponential moving average (EMA) of the price with a 5-minute half-life. Before allowing liquidation, it checks:
\begin{equation}
\frac{P_{\text{EMA}} - P_{\text{spot}}}{P_{\text{EMA}}} \leq 10\%
\end{equation}

If the spot price has diverged more than 10\% below the EMA, liquidation is blocked. This prevents atomically profitable manipulation attacks where an adversary crashes the price temporarily to liquidate positions, then immediately reverts the price.

\subsection{Liquidation Conditions}

A position can be liquidated if and only if:
\begin{enumerate}
    \item The payout is positive (position not underwater)
    \item The payout $P \leq 5\%$ of the position's gross value
    \item The EMA divergence check passes (no manipulation detected)
\end{enumerate}

The liquidator's reward is the entire remaining payout. Upon liquidation, the pool's state is updated using the same logic as closing a position, with the effective $\Delta k$ removed from the global debt tracking.

\section{Limbo State}

A position enters "limbo" when it meets the liquidation condition but no liquidator has closed it. It can exit limbo if price movements cause recovery: $x_e \cdot y_{\text{effective}} > \Delta k_{\text{effective}}$. Underwater positions still pay the LP funding rate, and thus their effective debt and size will amortize to 0 over time.

\section{Liquidity Provisioning and Launching}

Facemelt enables permissionless token launches with zero seed capital, using a bonding curve model similar to pump.fun. Traders who buy the token on the bonding curve essentially fund the LP once the token reaches the bonding threshold and graduates to the AMM.

\section{System Properties}

Facemelt's design provides several important properties:

\subsection{Solvency}

The protocol is always solvent because the pricing mechanism ensures that the output can never exceed the real reserve, regardless of input size.

\subsection{No Seed Capital Requirement}

The bonding curve based token launch mechanism allows early traders to become liquidity providers, and eliminates the need for external LPs.

\subsection{Economic Incentive Alignment}

The quadratic funding rate and effective reserve model create powerful incentive alignment:
\begin{itemize}
    \item \textbf{Leverage traders}: Continuous debt repayment through funding incentivizes closing positions, especially when the funding rate is high due to heavy pool utilization.
    \item \textbf{Spot traders \& LPs}: Benefit from the continuous growth of the effective reserves, which are fed by the funding payments from leverage traders. This leads to deeper liquidity and better execution prices over time.
    \item \textbf{Protocol}: The dynamic funding rate creates a natural economic cap on total system leverage. As total $\Delta k$ grows relative to the effective liquidity $k_e$, the funding rate accelerates, making new leverage prohibitively expensive.
\end{itemize}

\section{Considerations and Future Work}

Facemelt makes the tradeoff of temporarily reducing effective liquidity for traders in order to power leverage. This liquidity is restored through the LP funding rate and settled when positions are closed or liquidated. This tradeoff was chosen because in order to not reduce effective liquidity for traders, solvency would not be guaranteed in extreme cases (bank runs).
\\\\
However, if liquidations were integrated at the protocol level (i.e. swaps liquidate positions that would become underwater), effective liquidity could remain constant. This is an ideal scenario - designing such a liquidation mechanism that can stay within the limits of compute usage in smart contracts is very difficult, if possible.
\\\\
Future work will involve designing a liquidation engine integrated at the protocol level, and exploring other fundamentally different AMM mechanisms (concentrated liquidity/liquidity bins for example) that create a net improvement to the protocol.

\end{document} 